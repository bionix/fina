#!/bin/bash

# $Id: fina.sh 22 2007-11-18 16:16:45Z klausman $

# Fina v0.1 Copyright (C) 2007 Tobias Klausmann
# Released under the GPLv2. See the file COPYING for details.

# This is the place where the main config file resides.
FINACFG="/etc/fina/fina.cfg"

# If on your system, some tools are on a different PATH, you can
# configure them here
FIND=$(which find)
SORT=$(which sort)
MODPROBE=$(which modprobe)
IPTRESTORE=$(which iptables-restore)
IPTSAVE=$(which iptables-save)
# --------------- Nothing to configure below here --------------- #

PROGNAME="$0"
VERSION="0.1.2"
DEBUG="0"

# Help function
function print_help() {
    {
    echo "Usage: ${PROGNAME} --help|-h"
    echo "   or: ${PROGNAME} [OPTIONS]" 
    echo "" 
    echo "Options:" 
    echo "   -v, --version    Output script version, then exit."
    echo "   -p, --pretend    Don't load rules, just print them to stdout. (default)" 
    echo "   -l, --load       Create rules and load them" 
    echo "   -t, --terse      Remove all comments and empty lines from output when in"
    echo "                    'pretend' mode"
    echo "   -k, --keep       Keep files generated in /tmp"
    echo "" 
    echo "The modes -p and -l are mutually exclusive, the last one of those encountered"
    echo "on the command line is used."
    } >&2
}

function print_version() {
    echo "Fina version $VERSION"
    echo "(C) 2007 Tobias Klausmann." 
    echo "This is free software"  
    echo "You may redistribute copies of it under the terms of the GNU GPLv2"
    echo "http://www.gnu.org/licenses/old-licenses/gpl-2.0.html"
    echo "There is NO WARRANTY, to the extent permitted by law."
}

# Debug printing 
function dprint() {
    if [[ $DEBUG == 1 ]]; then
        echo  -e "$@" >&2
    fi
}

# Error printing 
function eprint() {
    echo  -e "$@" >&2
}

# Exit with message and error code
function die() {
    eprint "$@"
    exit -1
}

# Function that retrieves all rule files in lexical order
function get_rule_files () {
    # The trailing / is necessary in case ${RULESDIR} is a symlink
    $FIND ${RULESDIR}/ -name \*.rules -a \( -type f -o -type l \) -print|$SORT
}

# Function to create a temporary space for the file(s) we create
function get_tmpdir () {
    local UMASK=$(umask) # So we can restore it
    local OK=1
    local TRIES=3
    local TMPDIR=''
    umask 0077
    while [[ $OK != 0 && "$TRIES" -gt 0 ]]; do
        TMPDIR=/tmp/fina-$RANDOM$RANDOM
        TRIES=$(($TRIES-1))
        dprint "Trying to create $TMPDIR (tries left: $TRIES)" >&2
        mkdir "$TMPDIR" && OK=0
    done
    if [[ $OK != 0 ]]; then
        echo "Could not create TMPDIR."
        exit -1
    fi
    echo "${TMPDIR}"
    umask "$UMASK"
}

# Defaults
PRETEND=1
TERSE=0
KEEPTEMP=0

# Get cfg file contents
. "${FINACFG}" || die "Could not load config from $FINACFG"

# Parse cmdline
while test -n "$1"; do
    case "$1" in
        --help|-h)
            print_help
            exit 0
            ;;
        --version|-v)
            print_version
            exit 0
            ;;
        --pretend|-p)
            PRETEND=1
            ;;
        --keep|-k)
            KEEPTEMP=1
            ;;
        --load|-l)
            PRETEND=0
            ;;
        --terse|-t)
            TERSE=1
            ;;
        *)
            echo "Unknown option '$1'"
            print_help
            exit 1
    esac
    shift
done

dprint "After cmdline. Programs are:"
dprint "FIND='$FIND'"
dprint "SORT='$SORT'"
dprint "MODPROBE='$MODPROBE'"
dprint "IPTRESTORE='$IPTRESTORE'"
dprint "IPTSAVE='$IPTSAVE'"
dprint ""
dprint "Program mode: PRETEND=$PRETEND KEEPTEMP=$KEEPTEMP LOAD=$LOAD"

# First, load the modules
dprint "Trying to load modules specified in '$AUTOMODS'"
MODULES=$(sed -e 's/#.*//g' "$AUTOMODS" 2>/dev/null| grep -Ev '(^[[:space:]]*$)')
dprint "Module list: \n$MODULES"
for MODULE in $MODULES; do
    if [[ $PRETEND != 1 ]]; then
        # We let stderr/stdout of the modprobe get to the user
        modprobe $MODULE || die "Loading of $MODULE failed, exiting"
    else 
        echo "#Fina# Would execute: modprobe $MODULE" >&2
    fi
done

# Now, lets get the rule files
dprint "Searching rules in '${RULESDIR}'"
RULEFILES=$(get_rule_files)
dprint "Found:\n$RULEFILES"

# Get a tmpfile to put assembled rules in
TMPDIR=$(get_tmpdir)

# Save the old rules if we're not pretending -or- if we're told to keep stuff
if [[ $PRETEND != 1 || $KEEPTEMP == 1 ]]; then
    $IPTSAVE > $TMPDIR/rules.old
fi


# Generate the new rule file
{
    echo -n "#Fina# Generated by Fina v${VERSION} on "
    date -Is
    echo 
    for RULEFILE in $RULEFILES; do
        echo "#Fina# BEGIN of file '$RULEFILE'"
        # Comments only work if there is *nothing* before the #, so
        # we remove all trailing comments (first expression) and remove
        # all whitespace-sequences before comment line (second expression)
        sed -re 's/([^	 ]+)[	 ]*#.*/\1/g' -e 's/^[   ]*#/#/g' "$RULEFILE"
        RETVAL=$?
        if [[ $RETVAL != 0 ]]; then
            eprint "Could not open '$RULEFILE' (Error code '$RETVAL')"
            eprint "I have left all the files I generated in $TMPDIR"
            exit -2
        fi
        echo "#Fina# END of file '$RULEFILE'"
    done
    echo -n "#Fina# Generation complete on "
    date -Is 
} > "$TMPDIR/rules.new"

if [[ $PRETEND == 1 ]]; then
    if [[ $TERSE == 1 ]]; then
        grep -Ev '(^$|^[[:space:]]*#)' -- "$TMPDIR/rules.new"
    else
        cat "$TMPDIR/rules.new"
    fi
else
    dprint "Loading rules from file $TMPDIR/rules.new"
    MESG=$(iptables-restore < "$TMPDIR/rules.new" 2>&1)
    RETVAL=$?
    if [[ $RETVAL != 0 ]]; then
        eprint "Something went wrong (retval $RETVAL). Message:"
        eprint "$MESG"
        eprint "Loading old ruleset from $TMPDIR/rules.old"
        MESG=$(iptables-restore < "$TMPDIR/rules.old" 2>&1)
        RETVAL=$?
        if [[ $RETVAL != 0 ]]; then
            eprint "Even the old ruleset could not be loaded. Message:"
            eprint "$MESG"
        fi
        eprint "I have left all the files I generated in $TMPDIR"
        exit -1
    fi
fi

if [[ $KEEPTEMP != 1 ]]; then
    rm -rf $TMPDIR
fi

# vim: tabstop=4:shiftwidth=4:smarttab:expandtab:softtabstop=4:smartindent
